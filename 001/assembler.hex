# Copyright (c) 2022 Taylor Santos
# MIT License

# [0x0000]
# ELF Header
7f 45 4c 46              # EI_MAG:        ELF Magic Number
02                       # EI_CLASS:      64-bit
01                       # EI_DATA:       Little-Endian
01                       # EI_VERSION:    ELF Version
00                       # EI_OSABI:      System V
00                       # EI_ABIVERSION: ABI Version
00 00 00 00 00 00 00     # EI_PAD:        Padding
02 00                    # e_type:        ET_EXEC
3e 00                    # e_machine:     AMD x86-64
01 00 00 00              # e_version:     ELF Version 1
00 10 40 00 00 00 00 00  # e_entry:     * Entry Point Address
40 00 00 00 00 00 00 00  # e_phoff:       Program Header Table Offset
fe 00 00 00 00 00 00 00  # e_shoff:       Section Header Table Offset
00 00 00 00              # e_flags
40 00                    # e_ehsize:      ELF Header Size
38 00                    # e_phentsize:   Program Header Table Entry Size
03 00                    # e_phnum:       Program Header Table Entry Count
40 00                    # e_shentsize:   Section Header Table Entry Size
04 00                    # e_shnum:       Section Header Table Entry Count
03 00                    # e_shstrndx:    Section Header Names Index
# +0x0040

# [0x0040]
# Program Header 0 - ELF and Program Headers
01 00 00 00              # p_type:        PT_LOAD Loadable Segment
04 00 00 00              # p_flags:       PF_R - Read
00 00 00 00 00 00 00 00  # p_offset:      Segment Offset
00 00 40 00 00 00 00 00  # p_vaddr:       Segment Virtual Address
00 00 40 00 00 00 00 00  # p_paddr:       Segment Physical Address
e8 00 00 00 00 00 00 00  # p_filesz:      Size of Segment in File Image
e8 00 00 00 00 00 00 00  # p_memsz:       Size of Segment in Memory
00 10 00 00 00 00 00 00  # p_align:       Alignment
# +0x0038

# [0x0078]
# Program Header 1 - .text Section
01 00 00 00              # p_type:        PT_LOAD Loadable Segment
05 00 00 00              # p_flags:       PF_R|PF_X - Read & Execute
00 10 00 00 00 00 00 00  # p_offset:    * Segment Offset
00 10 40 00 00 00 00 00  # p_vaddr:     * Segment Virtual Address
00 10 40 00 00 00 00 00  # p_paddr:     * Segment Physical Address
e9 00 00 00 00 00 00 00  # p_filesz:    * Size of Segment in File Image
e9 00 00 00 00 00 00 00  # p_memsz:     * Size of Segment in Memory
00 10 00 00 00 00 00 00  # p_align:       Alignment
# +0x0038

# [0x00B0]
# Program Header 2 - .bss Section
01 00 00 00              # p_type:        PT_LOAD Loadable Segment
06 00 00 00              # p_flags:       PF_R|PF_W - Read & Write
00 00 00 00 00 00 00 00  # p_offset:      Segment Offset
00 20 40 00 00 00 00 00  # p_vaddr:       Segment Virtual Address
00 20 40 00 00 00 00 00  # p_paddr:       Segment Physical Address
00 00 00 00 00 00 00 00  # p_filesz:      Size of Segment in File Image
80 00 00 00 00 00 00 00  # p_memsz:       Size of Segment in Memory
00 10 00 00 00 00 00 00  # p_align:       Alignment
# +0x0038

# [0x00E8]
# Section Header Name Table 
00                             # Leading Zero Byte
2e 73 68 73 74 72 74 61 62 00  # ".shstrtab"
2e 74 65 78 74 00              # ".text"
2e 62 73 73 00                 # ".bss"
# +0x0016

# [0x00FE]
# Section Table 0 (Reserved)
00 00 00 00              # sh_name
00 00 00 00              # sh_type
00 00 00 00 00 00 00 00  # sh_flags
00 00 00 00 00 00 00 00  # sh_addr
00 00 00 00 00 00 00 00  # sh_offset
00 00 00 00 00 00 00 00  # sh_size
00 00 00 00              # sh_link
00 00 00 00              # sh_info
00 00 00 00 00 00 00 00  # sh_addralign
00 00 00 00 00 00 00 00  # sh_entsize
# +0x0040

# [0x013E]
# Section Table 1
0b 00 00 00              # sh_name:        ".text"
01 00 00 00              # sh_type:        SHT_PROGBITS - Program Data
06 00 00 00 00 00 00 00  # sh_flags:       SHF_ALLOC|SHF_EXECINSTR - Occupies Memory and is Executable
00 10 40 00 00 00 00 00  # sh_addr:      * Virtual address in memory if loaded
00 10 00 00 00 00 00 00  # sh_offset:    * Offset in File Image
e9 00 00 00 00 00 00 00  # sh_size:      * Size in File Image
00 00 00 00              # sh_link:        Associated Section Index
00 00 00 00              # sh_info:        Extra Info
10 00 00 00 00 00 00 00  # sh_addralign:   Alignment
00 00 00 00 00 00 00 00  # sh_entsize:     Fixed Size Entry Size
# +0x0040

# [0x017E]
# Section Table 2
11 00 00 00              # sh_name:        ".bss"
08 00 00 00              # sh_type:        SHT_NOBITS - Program Space with No Data
03 00 00 00 00 00 00 00  # sh_flags:       SHF_WRITE|SHF_ALLOC - Writable and Occupies Memory
00 20 40 00 00 00 00 00  # sh_addr:        Virtual address in memory if loaded
00 20 00 00 00 00 00 00  # sh_offset:      Offset in File Image
80 00 00 00 00 00 00 00  # sh_size:        Size in File Image
00 00 00 00              # sh_link:        Associated Section Index
00 00 00 00              # sh_info:        Extra Info
04 00 00 00 00 00 00 00  # sh_addralign:   Alignment
00 00 00 00 00 00 00 00  # sh_entsize:     Fixed Size Entry Size
# +0x0040

# [0x01BE]
# Section Table 3
01 00 00 00              # sh_name:        ".shstrtab"
03 00 00 00              # sh_type:        SHT_STRTAB - String Table
00 00 00 00 00 00 00 00  # sh_flags:       None
00 00 00 00 00 00 00 00  # sh_addr:        Virtual address in memory if loaded
e8 00 00 00 00 00 00 00  # sh_offset:      Offset in File Image
16 00 00 00 00 00 00 00  # sh_size:        Size in File Image
00 00 00 00              # sh_link:        Associated Section Index
00 00 00 00              # sh_info:        Extra Info
01 00 00 00 00 00 00 00  # sh_addralign:   Alignment
00 00 00 00 00 00 00 00  # sh_entsize:     Fixed Size Entry Size
# +0x0040

# [0x01FE]
# Padding to align .text to 0x1000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000
# +0x0E02

# Register allocations:
#   rax    get* return value
#   rbx    current hex digit
#   r12    in index
#   r13    in size
#   r14    out index
#   r15    out ptr

# [0x1000]
# _start:
    41 bc 40 00 00 00      # mov    r12d, insz          ; in buf index
    41 bd 40 00 00 00      # mov    r13d, insz          ; in read length
    4d 31 f6               # xor    r14, r14            ; out buf index
    49 bf 40 20 40 00 00   # movabs r15, outbuf         ; out buf pointer
    00 00 00               #                            ;
# prompt: +25              #                            ;
    e8 22 00 00 00         # call   gethex              ; read the next hex value into rax
    88 c3                  # mov    bl, al              ; copy digit into rbx
    c0 e3 04               # shl    bl, 0x4             ; left shift digit by 4
    e8 18 00 00 00         # call   gethex              ; read the next hex value into rax
    00 c3                  # add    bl, al              ; add the two digits together
    41 88 1f               # mov    [r15], bl           ; copy byte into buffer at current index
    49 ff c7               # inc    r15                 ; increment buffer pointer
    49 ff c6               # inc    r14                 ; increment buffer index
    49 83 fe 40            # cmp    r14, outsz          ;
    7c 05                  # jl     continue            ;
    e8 78 00 00 00         # call   flush               ; if the output buffer is full, flush it
# continue: +37            #                            ;
    eb d9                  # jmp    prompt              ;
# gethex: +2               #                            ;
    e8 36 00 00 00         # call   getchar             ; read in a char, then try to convert to hex
    3c 23                  # cmp    al, '#'             ;
    74 23                  # je     comment             ;
    3c 30                  # cmp    al, '0'             ;
    7c f3                  # jl     gethex              ;
    3c 39                  # cmp    al, '9'             ;
    7f 04                  # jg     gethex1             ;
    2c 30                  # sub    al, '0'             ;
    eb 16                  # jmp    rethex              ;
# gethex1: +21                                          ;
    3c 41                  # cmp    al, 'A'             ;
    7c e7                  # jl     gethex              ;
    3c 46                  # cmp    al, 'F'             ;
    7f 04                  # jg     gethex2             ;
    2c 37                  # sub    al, 'A'-0xA         ;
    eb 0a                  # jmp    rethex              ;
# gethex2: +12                                          ;
    3c 61                  # cmp    al, 'a'             ;
    7c db                  # jl     gethex              ;
    3c 66                  # cmp    al, 'f'             ;
    7f d7                  # jg     gethex              ;
    2c 57                  # sub    al, 'a'-0xA         ;
# rethex: +10                                           ;
    c3                     # ret                        ;
# comment: +1                                           ;
    e8 0a 00 00 00         # call   getchar             ; loop reading chars until a newline is hit
    3c 0a                  # cmp    al, '\n'            ;
    74 cb                  # je     gethex              ;
    3c 0d                  # cmp    al, '\r'            ;
    74 c7                  # je     gethex              ;
    eb f1                  # jmp    comment             ;
# getchar: +15                                          ;
    4d 39 ec               # cmp    r12, r13            ; check if index has reached end of input buffer
    7c 23                  # jl     nextchar            ;
    48 31 c0               # xor    rax, rax            ; read()
    48 31 ff               # xor    rdi, rdi            ; STDIN
    48 be 00 20 40 00 00   # movabs rsi, inbuf          ; buf
    00 00 00               #                            ;
    ba 40 00 00 00         # mov    edx, insz           ; count
    0f 05                  # syscall                    ;
    48 83 f8 00            # cmp    rax, 0x0            ; if read() returned 0...
    74 12                  # je     done                ; ...flush and exit
    49 89 c5               # mov    r13, rax            ; store read count as new buffer size
    4d 31 e4               # xor    r12, r12            ; reset input buf index
# nextchar: +40                                         ;
    49 8b 84 24 00 20 40   # mov    rax, [r12+inbuf]    ;
    00                     #                            ;
    49 ff c4               # inc    r12                 ;
    c3                     # ret                        ;
# done: +12                                             ;
    e8 02 00 00 00         # call   flush               ;
    eb 27                  # jmp    exit                ;
# flush: +7                                             ;
    b8 01 00 00 00         # mov    eax, 0x1            ; write()
    bf 01 00 00 00         # mov    edi, 0x1            ; STDOUT
    48 be 40 20 40 00 00   # movabs rsi, outbuf         ; buf
    00 00 00               #                            ;
    4c 89 f2               # mov    rdx, r14            ; len
    0f 05                  # syscall                    ;
    4d 31 f6               # xor    r14, r14            ; buffer index
    49 bf 40 20 40 00 00   # movabs r15, outbuf         ; buffer pointer
    00 00 00               #                            ;
    c3                     # ret                        ;
# exit: +39                                             ;
    b8 3c 00 00 00         # mov    eax, 0x3c           ; exit()
    bf 00 00 00 00         # mov    edi, 0x0            ; return code
    0f 05                  # syscall                    ;
# +12
# +0x00E9
