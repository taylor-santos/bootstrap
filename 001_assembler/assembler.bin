# [0x0000]
# ELF Header
7f 45 4c 46              # EI_MAG:        ELF Magic Number
02                       # EI_CLASS:      64-bit
01                       # EI_DATA:       Little-Endian
01                       # EI_VERSION:    ELF Version
00                       # EI_OSABI:      System V
00                       # EI_ABIVERSION: ABI Version
00 00 00 00 00 00 00     # EI_PAD:        Padding
02 00                    # e_type:        ET_EXEC
3e 00                    # e_machine:     AMD x86-64
01 00 00 00              # e_version:     ELF Version 1
00 01 40 00 00 00 00 00  # e_entry:     * Entry Point Address
40 00 00 00 00 00 00 00  # e_phoff:       Program Header Table Offset
08 02 00 00 00 00 00 00  # e_shoff:     * Section Header Table Offset
00 00 00 00              # e_flags
40 00                    # e_ehsize:      ELF Header Size
38 00                    # e_phentsize:   Program Header Table Entry Size
03 00                    # e_phnum:       Program Header Table Entry Count
40 00                    # e_shentsize:   Section Header Table Entry Size
04 00                    # e_shnum:       Section Header Table Entry Count
03 00                    # e_shstrndx:    Section Header Names Index
# +0x0040

# [0x0040]
# Program Header 0 - ELF and Program Headers
01 00 00 00              # p_type:        PT_LOAD Loadable Segment
04 00 00 00              # p_flags:       PF_R - Read
00 00 00 00 00 00 00 00  # p_offset:      Segment Offset
00 00 40 00 00 00 00 00  # p_vaddr:       Segment Virtual Address
00 00 40 00 00 00 00 00  # p_paddr:       Segment Physical Address
e8 00 00 00 00 00 00 00  # p_filesz:      Size of Segment in File Image
e8 00 00 00 00 00 00 00  # p_memsz:       Size of Segment in Memory
00 10 00 00 00 00 00 00  # p_align:       Alignment
# +0x0038

# [0x0078]
# Program Header 1 - .text Section
01 00 00 00              # p_type:        PT_LOAD Loadable Segment
05 00 00 00              # p_flags:       PF_R|PF_X - Read & Execute
00 01 00 00 00 00 00 00  # p_offset:    * Segment Offset
00 01 40 00 00 00 00 00  # p_vaddr:     * Segment Virtual Address
00 01 40 00 00 00 00 00  # p_paddr:     * Segment Physical Address
f0 00 00 00 00 00 00 00  # p_filesz:      Size of Segment in File Image
f0 00 00 00 00 00 00 00  # p_memsz:       Size of Segment in Memory
00 10 00 00 00 00 00 00  # p_align:       Alignment
# +0x0038

# [0x00B0]
# Program Header 2 - .bss Section
01 00 00 00              # p_type:        PT_LOAD Loadable Segment
06 00 00 00              # p_flags:       PF_R|PF_W - Read & Write
00 00 00 00 00 00 00 00  # p_offset:      Segment Offset
00 20 40 00 00 00 00 00  # p_vaddr:       Segment Virtual Address
00 20 40 00 00 00 00 00  # p_paddr:       Segment Physical Address
00 00 00 00 00 00 00 00  # p_filesz:      Size of Segment in File Image
40 00 00 00 00 00 00 00  # p_memsz:       Size of Segment in Memory
00 10 00 00 00 00 00 00  # p_align:       Alignment
# +0x0038

# [0x00E8]
# Padding to align .text to 0x0100
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
# +0x0018

# [0x0100]
# &buf = 0x402000
#  bsz = 0x40
# _start:
    4d 31 e4              # xor r12, r12
    4d 31 ed              # xor r13, r13
    49 be 00 20 40 00 00  # movabs buf, r14
    00 00 00
    48 83 ec 01           # sub rsp, 0x1
    48 89 e6              # mov rsi, rsp
# prompt: +23
    e8 2b 00 00 00        # call gethex
    4c 8b 0e              # mov r9, [rsi]
    49 c1 e1 04           # shl r9, 0x4
    e8 1f 00 00 00        # call gethex
    4c 03 0e              # add r9, [rsi]
    45 88 0e              # mov [r14], r9b
    49 ff c6              # inc r14
    49 ff c5              # inc r13
    49 83 fd 40           # cmp r13, bsz
    7c 05                 # jl continue
    e8 7e 00 00 00        # call flush
# continue: +40
    48 89 e6              # mov rsi, rsp
    48 ff c6              # inc rsi
    eb d0                 # jmp prompt
# gethex: +8
    e8 57 00 00 00        # call getchar
    44 8a 06              # mov r8b, [rsi]
    49 83 f8 23           # cmp r8, '#'
    74 38                 # je comment
    49 83 f8 30           # cmp r8, '0'
    7c ec                 # jl gethex
    49 83 f8 39           # cmp r8, '9'
    7f 06                 # jg gethex1
    49 83 e8 30           # sub r8, '0'
    eb 22                 # jmp rethex
# gethex1: +32
    49 83 f8 41           # cmp r8, 'A'
    7c da                 # jl gethex
    49 83 f8 46           # cmp r8, 'F'
    7f 06                 # jg gethex2
    49 83 e8 37           # sub r8, 'A'-0xA
    eb 10                 # jmp rethex
# gethex2: +18
    49 83 f8 61           # cmp r8, 'a'
    7c c8                 # jl gethex
    49 83 f8 66           # cmp r8, 'f'
    7f c2                 # jg gethex
    49 83 e8 57           # sub r8, 'a'-0xA
# rethex: +16
    44 88 06              # mov [rsi], r8b
    c3                    # ret
# comment: +4
    e8 11 00 00 00        # call getchar
    44 8a 06              # mov r8b, [rsi]
    49 83 f8 0a           # cmp r8, `\n`
    74 ac                 # je gethex
    49 83 f8 0d           # cmp r8, `\r`
    74 a6                 # je gethex
    eb ea                 # jmp comment
# getchar: +22
    31 c0                 # xor eax, eax    ; read()
    48 31 ff              # xor rdi, rdi    ; STDIN
    ba 01 00 00 00        # mov edx, 0x1    ; count
    0f 05                 # syscall
    48 83 f8 00           # cmp rax, 0x0    ; check EOF
    74 01                 # je done
    c3                    # ret
# done: +19
    e8 02 00 00 00        # call flush
    eb 27                 # jmp exit
# flush: +7
    b8 01 00 00 00        # mov eax, 0x1    ; write()
    bf 01 00 00 00        # mov edi, 0x1    ; STDOUT
    48 be 00 20 40 00 00  # mov rsi, buf    ; buf
    00 00 00
    4c 89 ea              # mov rdx, r13    ; len
    0f 05                 # syscall
    4d 31 ed              # xor r13, r13    ; buffer index
    49 be 00 20 40 00 00  # mov r14, buf    ; buffer pointer
    00 00 00
    c3                    # ret
# exit +39
    b8 3c 00 00 00        # mov rax, 0x3c   ; exit()
    bf 00 00 00 00        # mov rdi, 0x0    ; return code
    0f 05                 # syscall
# +12
# +0x00F0

# [0x01F0]
# Section Header Name Table 
00                             # Leading Zero Byte
2e 73 68 73 74 72 74 61 62 00  # ".shstrtab"
2e 74 65 78 74 00              # ".text"
2e 62 73 73 00                 # ".bss"

00 00
# +0x0018

# [0x0208]
# Section Table 0 (Reserved)
00 00 00 00              # sh_name
00 00 00 00              # sh_type
00 00 00 00 00 00 00 00  # sh_flags
00 00 00 00 00 00 00 00  # sh_addr
00 00 00 00 00 00 00 00  # sh_offset
00 00 00 00 00 00 00 00  # sh_size
00 00 00 00              # sh_link
00 00 00 00              # sh_info
00 00 00 00 00 00 00 00  # sh_addralign
00 00 00 00 00 00 00 00  # sh_entsize
# +0x0040

# [0x0208]
# Section Table 1
0b 00 00 00              # sh_name:        ".text"
01 00 00 00              # sh_type:        SHT_PROGBITS - Program Data
06 00 00 00 00 00 00 00  # sh_flags:       SHF_ALLOC|SHF_EXECINSTR - Occupies Memory and is Executable
00 01 40 00 00 00 00 00  # sh_addr:      * Virtual address in memory if loaded
00 01 00 00 00 00 00 00  # sh_offset:    * Offset in File Image
f0 00 00 00 00 00 00 00  # sh_size:        Size in File Image
00 00 00 00              # sh_link:        Associated Section Index
00 00 00 00              # sh_info:        Extra Info
10 00 00 00 00 00 00 00  # sh_addralign:   Alignment
00 00 00 00 00 00 00 00  # sh_entsize:     Fixed Size Entry Size
# +0x0040

# [0x0248]
# Section Table 2
11 00 00 00              # sh_name:        ".bss"
08 00 00 00              # sh_type:        SHT_NOBITS - Program Space with No Data
03 00 00 00 00 00 00 00  # sh_flags:       SHF_WRITE|SHF_ALLOC - Writable and Occupies Memory
00 20 40 00 00 00 00 00  # sh_addr:        Virtual address in memory if loaded
00 20 00 00 00 00 00 00  # sh_offset:      Offset in File Image
40 00 00 00 00 00 00 00  # sh_size:        Size in File Image
00 00 00 00              # sh_link:        Associated Section Index
00 00 00 00              # sh_info:        Extra Info
04 00 00 00 00 00 00 00  # sh_addralign:   Alignment
00 00 00 00 00 00 00 00  # sh_entsize:     Fixed Size Entry Size
# +0x0040

# [0x0288]
# Section Table 3
01 00 00 00              # sh_name:        ".shstrtab"
03 00 00 00              # sh_type:        SHT_STRTAB - String Table
00 00 00 00 00 00 00 00  # sh_flags:       None
00 00 00 00 00 00 00 00  # sh_addr:        Virtual address in memory if loaded
f0 01 00 00 00 00 00 00  # sh_offset:    * Offset in File Image
16 00 00 00 00 00 00 00  # sh_size:        Size in File Image
00 00 00 00              # sh_link:        Associated Section Index
00 00 00 00              # sh_info:        Extra Info
01 00 00 00 00 00 00 00  # sh_addralign:   Alignment
00 00 00 00 00 00 00 00  # sh_entsize:     Fixed Size Entry Size
# +0x0040
