     1                                  ; Copyright (c) 2022 Taylor Santos
     2                                  ; MIT License
     3                                  
     4                                  ; assembler.asm
     5                                  bits    64
     6                                  global  _start
     7                                  
     8                                  brkinc: equ 4096
     9                                  
    10                                  section .rodata
    11 00000000 63616C6C                    im_call:    db      'call'
    12                                      il_call     equ $-im_call
    13 00000004 636D70                      im_cmp:     db      'cmp'
    14                                      il_cmp      equ $-im_cmp
    15 00000007 696E63                      im_inc:     db      'inc'
    16                                      il_inc      equ $-im_inc
    17 0000000A 6A65                        im_je:      db      'je'
    18                                      il_je       equ $-im_je
    19 0000000C 6A6D70                      im_jmp:     db      'jmp'
    20                                      il_jmp      equ $-im_jmp
    21 0000000F 6A6E65                      im_jne:     db      'jne'
    22                                      il_jne      equ $-im_jne
    23 00000012 6C6561                      im_lea:     db      'lea'
    24                                      il_lea      equ $-im_lea
    25 00000015 6D6F76                      im_mov:     db      'mov'
    26                                      il_mov      equ $-im_mov
    27 00000018 726574                      im_ret:     db      'ret'
    28                                      il_ret      equ $-im_ret
    29 0000001B 737562                      im_sub:     db      'sub'
    30                                      il_sub      equ $-im_sub
    31 0000001E 73797363616C6C              im_syscall: db      'syscall'
    32                                      il_syscall  equ $-im_syscall
    33 00000025 74657374                    im_test:    db      'test'
    34                                      il_test     equ $-im_test
    35 00000029 786F72                      im_xor:     db      'xor'
    36                                      il_xor      equ $-im_xor
    37                                  
    38                                  op_table:
    39 0000002C [0000000000000000]          dq im_call
    40                                      op_im_sz: equ $-op_table
    41 00000034 04                          db il_call
    42                                      op_row_sz: equ $-op_table
    43 00000035 [0400000000000000]          dq im_cmp
    44 0000003D 03                          db il_cmp
    45 0000003E [0700000000000000]          dq im_inc
    46 00000046 03                          db il_inc
    47 00000047 [0A00000000000000]          dq im_je
    48 0000004F 02                          db il_je
    49 00000050 [0C00000000000000]          dq im_jmp
    50 00000058 03                          db il_jmp
    51 00000059 [0F00000000000000]          dq im_jne
    52 00000061 03                          db il_jne
    53 00000062 [1200000000000000]          dq im_lea
    54 0000006A 03                          db il_lea
    55 0000006B [1500000000000000]          dq im_mov
    56 00000073 03                          db il_mov
    57 00000074 [1800000000000000]          dq im_ret
    58 0000007C 03                          db il_ret
    59 0000007D [1B00000000000000]          dq im_sub
    60 00000085 03                          db il_sub
    61 00000086 [1E00000000000000]          dq im_syscall
    62 0000008E 07                          db il_syscall
    63 0000008F [2500000000000000]          dq im_test
    64 00000097 04                          db il_test
    65 00000098 [2900000000000000]          dq im_xor
    66 000000A0 03                          db il_xor
    67                                  
    68                                      op_table_end: equ $
    69                                      op_row_ct: equ (op_table_end-op_table)/op_row_sz
    70                                  
    71 000000A1 0A00                    newline: db `\n`, 0
    72                                  
    73                                  section .bss
    74                                  
    75                                  section .text
    76                                  _start:
    77                                      ; call brk(0) to get start of break
    78 00000000 31FF                        xor edi, edi
    79 00000002 E82A020000                  call brk
    80                                      ; save start of break to $RBX
    81 00000007 4889C3                      mov rbx, rax
    82                                      ; read in
    83 0000000A E8B6010000                  call stdin_to_heap
    84                                      ; tokenize input
    85 0000000F 4889DF                      mov rdi, rbx                ; arg1 - buf
    86 00000012 4889C6                      mov rsi, rax                ; arg2 - count
    87 00000015 E850000000                  call tokenize
    88                                      ; exit(0)
    89 0000001A 31FF                        xor edi, edi
    90 0000001C E95E020000                  jmp exit
    91                                  
    92                                  
    93                                  ; EDI - char
    94                                  is_ident_start:
    95 00000021 4080FF2E                    cmp dil, '.'
    96 00000025 7428                        je is_ident2
    97 00000027 83EF41                      sub edi, 'A'
    98 0000002A 4080FF39                    cmp dil, '9'
    99 0000002E 7625                        jna is_ident3
   100 00000030 31C0                        xor eax, eax
   101 00000032 C3                          ret
   102                                  
   103                                  ; EDI - char
   104                                  is_ident:
   105 00000033 4080FF39                    cmp dil, '9'
   106 00000037 760C                        jbe is_ident1
   107 00000039 83EF41                      sub edi, 'A'
   108 0000003C 4080FF39                    cmp dil, '9'
   109 00000040 7613                        jna is_ident3
   110 00000042 31C0                        xor eax, eax
   111 00000044 C3                          ret
   112                                  is_ident1:
   113 00000045 31C0                        xor eax, eax
   114 00000047 4080FF2F                    cmp dil, 47
   115 0000004B 0F97C0                      seta al
   116 0000004E C3                          ret
   117                                  
   118                                  is_ident2:
   119 0000004F B801000000                  mov eax, 1
   120 00000054 C3                          ret
   121                                  
   122                                  is_ident3:
   123 00000055 48B8FFFFFF43FFFFFF-         mov rax, 0x3FFFFFF43FFFFFF
   123 0000005E 03                 
   124 0000005F 480FA3F8                    bt rax, rdi
   125 00000063 0F92C0                      setc al
   126 00000066 0FB6C0                      movzx eax, al
   127 00000069 C3                          ret
   128                                  
   129                                  ; RDI - input string
   130                                  ; RSI - input length
   131                                  tokenize:
   132 0000006A 4989FB                      mov r11, rdi                ; store input ptr in r11
   133 0000006D 4C8D2437                    lea r12, [rdi + rsi]        ; store input end ptr in r12
   134                                      ; get current program break and store it in r15
   135 00000071 31FF                        xor edi, edi
   136 00000073 E8B9010000                  call brk
   137 00000078 4989C7                      mov r15, rax
   138                                  tokenize_loop:
   139                                      ; check if at end of input
   140 0000007B 4D39E3                      cmp r11, r12
   141                                      ; end loop if at end
   142 0000007E 0F8D9C000000                jge tokenize_end
   143 00000084 458A2B                      mov r13b, BYTE [r11]        ; get current char in r13b
   144                                      ; call is_ident_start() on current char
   145 00000087 4489EF                      mov edi, r13d
   146 0000008A E892FFFFFF                  call is_ident_start
   147 0000008F 4885C0                      test rax, rax
   148 00000092 750B                        jne tokenize_ident
   149                                      
   150 00000094 4183FD23                    cmp r13d, '#'
   151 00000098 7458                        je tokenize_comment
   152                                  
   153 0000009A 49FFC3                      inc r11
   154 0000009D EBDC                        jmp tokenize_loop
   155                                  
   156                                  tokenize_ident:
   157                                      ; char is ident
   158                                      ; TODO
   159 0000009F 4D89DE                      mov r14, r11                ; store start of ident in r14
   160                                  tokenize_ident2:
   161 000000A2 49FFC3                      inc r11
   162                                      ; check for end of input
   163 000000A5 4D39E3                      cmp r11, r12
   164                                      ; end loop if at end
   165 000000A8 7D10                        jge tokenize_keyword
   166 000000AA 458A2B                      mov r13b, BYTE [r11]        ; store current char in r13b
   167                                      ; check if char is alphanumeric
   168 000000AD 4489EF                      mov edi, r13d
   169 000000B0 E87EFFFFFF                  call is_ident
   170 000000B5 4885C0                      test rax, rax
   171 000000B8 75E8                        jne tokenize_ident2
   172                                      
   173                                  tokenize_keyword:
   174                                      ; finished lexing ident, check if it's a known keyword
   175 000000BA 4C89F7                      mov rdi, r14
   176 000000BD 4C89DE                      mov rsi, r11
   177 000000C0 4C29F6                      sub rsi, r14
   178 000000C3 E8BC000000                  call match_keyword
   179 000000C8 4883F8FF                    cmp rax, -1
   180 000000CC 743D                        je tokenize_found_ident
   181                                      ; found keyword
   182 000000CE 4C89F7                      mov rdi, r14
   183 000000D1 4C89DE                      mov rsi, r11
   184 000000D4 4C29F6                      sub rsi, r14
   185 000000D7 E83C010000                  call puts
   186                                  
   187 000000DC 48BF-                       mov rdi, newline
   187 000000DE [A100000000000000] 
   188 000000E6 BE01000000                  mov rsi, 1
   189 000000EB E828010000                  call puts
   190                                  
   191 000000F0 EB89                        jmp tokenize_loop
   192                                  
   193                                  tokenize_comment:
   194                                      ; comment
   195 000000F2 49FFC3                      inc r11
   196 000000F5 4D39E3                      cmp r11, r12
   197                                      ; end loop if at end
   198 000000F8 7D26                        jge tokenize_end
   199                                      ; loop until newline is encountered
   200 000000FA 458A2B                      mov r13b, BYTE [r11]        ; store current char in r13b
   201 000000FD 4180FD0A                    cmp r13b, `\n`
   202 00000101 75EF                        jne tokenize_comment
   203                                  
   204 00000103 49FFC3                      inc r11
   205 00000106 E970FFFFFF                  jmp tokenize_loop
   206                                  
   207                                  tokenize_found_ident:
   208 0000010B 31FF                        xor edi, edi                ; token type 0 = ident
   209 0000010D 4C89DE                      mov rsi, r11                ; ident length
   210 00000110 4C89F2                      mov rdx, r14                ; ident ptr
   211                                                                  ; heap ptr
   212 00000113 4D89F8                      mov r8, r15                 ; brk
   213 00000116 E806000000                  call write_token
   214 0000011B E95BFFFFFF                  jmp tokenize_loop
   215                                  
   216                                  tokenize_end:
   217 00000120 C3                          ret
   218                                  
   219                                  ; RDI - token type
   220                                  ; RSI - token data1
   221                                  ; RDX - token data2
   222                                  ; RCX - heap pointer
   223                                  ; R8  - current program break
   224                                  write_token:
   225 00000121 4155                        push r13
   226 00000123 4C89C0                      mov rax, r8
   227 00000126 4989F5                      mov r13, rsi
   228 00000129 4154                        push r12
   229 0000012B 4989FC                      mov r12, rdi
   230 0000012E 55                          push rbp
   231 0000012F 4889D5                      mov rbp, rdx
   232 00000132 488D5118                    lea rdx, [rcx+24]
   233 00000136 53                          push rbx
   234 00000137 4889CB                      mov rbx, rcx
   235 0000013A 4883EC08                    sub rsp, 8
   236 0000013E 4C39C2                      cmp rdx, r8
   237 00000141 7316                        jnb write_token2
   238                                  write_token1:
   239 00000143 4C8923                       mov QWORD [rbx], r12
   240 00000146 4C896B08                     mov QWORD [rbx+8], r13
   241 0000014A 48896B10                     mov QWORD [rbx+16], rbp
   242 0000014E 4883C408                     add rsp, 8
   243 00000152 5B                           pop rbx
   244 00000153 5D                           pop rbp
   245 00000154 415C                         pop r12
   246 00000156 415D                         pop r13
   247 00000158 C3                           ret
   248                                  write_token2:
   249 00000159 498DB800100000               lea rdi, [r8+4096]
   250 00000160 E8CC000000                   call brk
   251 00000165 EBDC                         jmp write_token1
   252                                  
   253                                  ; RDI - char
   254                                  is_alpha:
   255 00000167 83E7DF                      and edi, -33                ; unset the 6th bit to make uppercase
   256 0000016A 31C0                        xor eax, eax
   257 0000016C 83EF41                      sub edi, 'A'                ; shift values so 'A'=0 and 'Z'=25
   258 0000016F 4080FF19                    cmp dil, 25
   259 00000173 0F96C0                      setbe al                    ; set RAX to 1 if the value is between 0 and 25 inclusive, 0 otherwise
   260 00000176 C3                          ret
   261                                  
   262                                  ; RDI - char
   263                                  is_num:
   264 00000177 83EF30                      sub edi, '0'                ; shift so '0'=0 and '9'=9
   265 0000017A 31C0                        xor eax, eax
   266 0000017C 4080FF09                    cmp dil, 9                  ; check if input is between 0 and 9 inclusive
   267 00000180 0F96C0                      setbe al
   268 00000183 C3                          ret
   269                                  
   270                                  ; RDI - name string
   271                                  ; RSI - name length
   272                                  ; returns RAX - index of matched keyword, or -1 if no match
   273                                  ; clobbers RDX, RCX (via strncmp), R8, R9, R10
   274                                  match_keyword:
   275 00000184 4889F2                      mov rdx, rsi           ; store str length in rdx, arg3 for strncmp
   276 00000187 49BA-                       mov r10, op_table      ; store table ptr in R10
   276 00000189 [2C00000000000000] 
   277 00000191 4531C9                      xor r9d, r9d           ; store index in r9
   278                                  match_keyword1:
   279 00000194 458A4208                    mov r8b, BYTE [r10 + op_im_sz]
   280                                      ; check if table entry is same length as argument
   281 00000198 4939D0                      cmp r8, rdx
   282                                      ; loop if different lengths
   283 0000019B 7510                        jne match_keyword2
   284                                      ; if same lengths, call strncmp
   285 0000019D 498B32                      mov rsi, QWORD [r10]
   286 000001A0 E89A000000                  call strncmp
   287                                      ; if strings differ, increment and loop
   288 000001A5 85C0                        test eax, eax
   289 000001A7 7504                        jne match_keyword2
   290                                      ; if strings match, return index
   291 000001A9 4C89C8                      mov rax, r9
   292 000001AC C3                          ret
   293                                  match_keyword2:
   294                                      ; increment table pointer
   295 000001AD 4983C209                    add r10, op_row_sz
   296 000001B1 49FFC1                      inc r9
   297                                      ; check if table ptr is at end and loop if not
   298 000001B4 4981FA[A1000000]            cmp r10, op_table_end
   299 000001BB 7CD7                        jl match_keyword1
   300                                      ; if no matches found, return -1
   301 000001BD 48C7C0FFFFFFFF              mov rax, -1
   302 000001C4 C3                          ret
   303                                  
   304                                  
   305                                  stdin_to_heap:
   306 000001C5 4154                        push r12
   307 000001C7 55                          push rbp
   308 000001C8 53                          push rbx
   309                                      ; initialize total count to 0
   310 000001C9 31ED                        xor ebp, ebp
   311                                      ; brk(0) to get intial break
   312 000001CB 31FF                        xor edi, edi
   313 000001CD E85F000000                  call brk
   314                                      ; store initial break in $RCX
   315 000001D2 4889C3                      mov rbx, rax
   316                                  stdin_to_heap1:
   317                                      ; increment break by brkinc
   318 000001D5 4989DC                      mov r12, rbx
   319 000001D8 4881C300100000              add rbx, brkinc
   320 000001DF 4889DF                      mov rdi, rbx
   321 000001E2 E84A000000                  call brk
   322                                      ; read brkinc bytes from stdin
   323 000001E7 4C89E7                      mov rdi, r12
   324 000001EA BE00100000                  mov rsi, brkinc
   325 000001EF E817000000                  call read_stdin
   326                                      ; increment total count by amount read
   327 000001F4 4801C5                      add rbp, rax
   328                                      ; continue reading if full amount was consumed
   329 000001F7 483D00100000                cmp rax, brkinc
   330 000001FD 0F84D2FFFFFF                je NEAR stdin_to_heap1
   331                                      ; set return value to total count
   332 00000203 4889E8                      mov rax, rbp
   333 00000206 5B                          pop rbx
   334 00000207 5D                          pop rbp
   335 00000208 415C                        pop r12
   336 0000020A C3                          ret
   337                                  
   338                                  ; RDI - address of buffer
   339                                  ; RSI - number of bytes to read
   340                                  ; return RAX - number of bytes read
   341                                  read_stdin:
   342 0000020B 31C0                        xor eax, eax                ; SYS_read
   343 0000020D 4889F2                      mov rdx, rsi                ; count
   344 00000210 4889FE                      mov rsi, rdi                ; buf
   345 00000213 31FF                        xor edi, edi                ; STDIN
   346 00000215 0F05                        syscall
   347 00000217 C3                          ret
   348                                  
   349                                  ; RDI - address of buffer to read from
   350                                  ; RSI - number of bytes to write
   351                                  puts:
   352 00000218 4153                        push r11
   353 0000021A 51                          push rcx
   354 0000021B B801000000                  mov rax, 0x1                ; SYS_write
   355 00000220 4889F2                      mov rdx, rsi                ; count
   356 00000223 4889FE                      mov rsi, rdi                ; buf
   357 00000226 BF01000000                  mov rdi, 0x1                ; STDOUT
   358 0000022B 0F05                        syscall
   359 0000022D 59                          pop rcx
   360 0000022E 415B                        pop r11
   361 00000230 C3                          ret
   362                                  
   363                                  
   364                                  ; Sets the program break to the address supplied in $RDI
   365                                  ; Returns the new break in $RAX
   366                                  brk:
   367 00000231 4153                        push r11
   368 00000233 51                          push rcx
   369 00000234 B80C000000                  mov rax, 0x0c               ; SYS_brk
   370 00000239 0F05                        syscall
   371 0000023B 59                          pop rcx
   372 0000023C 415B                        pop r11
   373 0000023E C3                          ret
   374                                  
   375                                  ; RDI - str1
   376                                  ; RSI - str2
   377                                  ; RDX - n
   378                                  ; return RAX: returns 0 if equal, otherwise relative difference of first different char
   379                                  ; clobbers RCX, R8
   380                                  strncmp:
   381 0000023F 31C0                        xor eax, eax
   382 00000241 4885D2                      test rdx, rdx
   383 00000244 0F851A000000                jne NEAR strncmp2
   384 0000024A E92F000000                  jmp QWORD strncmp5
   385                                  strncmp1:
   386 0000024F 4438C1                      cmp cl, r8b
   387 00000252 0F851D000000                jne NEAR strncmp3
   388 00000258 48FFC0                      inc rax
   389 0000025B 4839C2                      cmp rdx, rax
   390 0000025E 0F8418000000                je NEAR strncmp4
   391                                  strncmp2:
   392 00000264 0FB60C07                    movzx ecx, BYTE [rdi + rax]
   393 00000268 440FB60406                  movzx r8d, BYTE [rsi + rax]
   394 0000026D 84C9                        test cl, cl
   395 0000026F 0F85DAFFFFFF                jne NEAR strncmp1
   396                                  strncmp3:
   397 00000275 0FB6C1                      movzx eax, cl
   398 00000278 4429C0                      sub eax, r8d
   399 0000027B C3                          ret
   400                                  strncmp4:
   401 0000027C 31C0                        xor eax, eax
   402                                  strncmp5:
   403 0000027E C3                          ret
   404                                  
   405                                  ; Terminates the process and returns the value supplied in $rdi
   406                                  exit:
   407 0000027F B83C000000                  mov rax, 0x3c               ; SYS_exit
   408 00000284 0F05                        syscall                     ; exit()
